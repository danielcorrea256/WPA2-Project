"""
client.py

Implements a simplified WPA2 client (supplicant) key management state machine
using a 4-Way Handshake-like process. This module demonstrates how a client,
which extends the basic cryptographic operations provided by the Entity class,
handles handshake messages, computes the PTK, and installs both PTK and GTK.

The parent class, Entity (located in entities/Entity.py), provides:
  - Nonce generation (generate_nonce)
  - PTK calculation (calc_ptk)
  - Key installation (install_ptk_and_gtk)
  - Message encryption (send_message)

Example Usage:
    1. Create a Client instance with a PMK, client MAC, and AP MAC.
    2. Process Message 1 to transition into PTK_START.
    3. Process Message 3 to install keys and finalize the handshake.
    4. Encrypt traffic using the installed Temporal Key (TK) in AES-CTR mode.
"""

from enum import Enum, auto
from entities.Entity import Entity
import numpy as np


class PTKState(Enum):
    """Enumeration of the PTK state machine states."""
    PTK_INIT = auto()
    PTK_START = auto()
    PTK_NEGOTIATING = auto()
    PTK_DONE = auto()


class Client(Entity):
    """
    A simplified WPA2 client (supplicant) state machine for key management in a
    4-Way Handshake process.

    This class extends the Entity class, which implements core cryptographic
    functions such as nonce generation, PTK calculation, and message encryption.
    The Client class adds state management to handle the handshake messages,
    track replay counters, and coordinate transitions between handshake states.

    Inherited from Entity:
        - generate_nonce(): Generates a pseudorandom nonce.
        - calc_ptk(): Calculates the Pairwise Transient Key (PTK).
        - install_ptk_and_gtk(): Installs the PTK and GTK, and initializes AES-CTR.
        - send_message(): Encrypts messages using the installed AES-CTR cipher.

    Attributes:
        state (PTKState): Current state in the PTK handshake flow.
        pmk (bytes): The Pairwise Master Key (PMK), inherited from Entity.
        mac (str): The MAC address of this client (supplicant), inherited from Entity.
        anonce (bytes): ANonce received from the AP (stored in Entity).
        snonce (bytes): SNonce generated by this client in PTK_START state (stored in Entity).
        tptk (bytes): Temporary PTK computed before final installation (stored in Entity).
        ptk (bytes): Final installed Pairwise Transient Key (stored in Entity).
        kck (bytes): Key Confirmation Key (not fully utilized here, stored in Entity).
        gtk (bytes): Group Temporal Key received in Message 3 (stored in Entity).
        tk (bytes): Temporal Key (subset of PTK) used for unicast encryption (stored in Entity).
        access_point_mac (str): MAC address of the access point (authenticator).
        replay_counter (int): Tracks replay counter values for handshake messages (stored in Entity).
        counter_encryption (Counter): AES-CTR counter object for encryption (stored in Entity).
        cipher (AES): AES cipher object for encrypting traffic in CTR mode (stored in Entity).
    """

    def __init__(self, pmk: bytes, mac: str, ap_mac: str):
        """
        Initializes the client state machine with a PMK, client MAC, and AP MAC.

        Args:
            pmk (bytes): The Pairwise Master Key.
            mac (str): MAC address of this client.
            ap_mac (str): MAC address of the access point.
        """
        super().__init__(pmk, mac)
        self.ap_mac = ap_mac
        self.state = PTKState.PTK_INIT

    def handle_message_1(self, message1: dict):
        """
        Handles receipt of Message 1 of the 4-Way Handshake.

        Transitions from PTK_INIT or PTK_START to PTK_START, storing the ANonce
        and replay counter, then generates SNonce and computes a temporary PTK
        (tPTK) using the parent's calc_ptk method.

        Args:
            message1 (dict): Dictionary representing Message 1, with keys:
                - "ANonce" (bytes): The ANonce from the AP.
                - "r" (int): The replay counter from the AP.
        """
        if self.state not in [PTKState.PTK_INIT, PTKState.PTK_START]:
            return

        self.anonce = message1["ANonce"]
        self.replay_counter = message1["r"]

        self.state = PTKState.PTK_START
        self.snonce = self.generate_nonce()
        self.tptk = self.calc_ptk(self.mac, self.ap_mac, self.snonce, self.anonce)

    def send_message_2(self) -> dict:
        """
        Constructs and returns Message 2 of the 4-Way Handshake.

        Returns:
            dict: A dictionary representing Message 2, containing:
                - "r" (int): The current replay counter.
                - "SNonce" (bytes): The client's SNonce.
        """
        message2 = {
            "r": self.replay_counter,
            "SNonce": self.snonce
        }
        return message2

    def send_message_4(self) -> dict:
        """
        Constructs and returns Message 4 of the 4-Way Handshake.

        Returns:
            dict: A dictionary representing Message 4, containing:
                - "r" (int): The current replay counter.
        """
        message4 = {
            "r": self.replay_counter
        }
        return message4

    def handle_message_3(self, message3: dict):
        """
        Handles receipt of Message 3 of the 4-Way Handshake.

        Transitions to PTK_NEGOTIATING if valid, installs the PTK and GTK using
        the parent's install_ptk_and_gtk method, and finalizes the handshake.

        Args:
            message3 (dict): Dictionary representing Message 3, with keys:
                - "gtk" (bytes): The Group Temporal Key from the AP.
                - "r" (int): The replay counter from the AP.
        """
        if self.state not in [PTKState.PTK_START, PTKState.PTK_NEGOTIATING]:
            return

        gtk = message3["gtk"]
        r = message3["r"]

        # Replay counter check
        if r <= self.replay_counter:
            print("Error: Replay counter did not increase. Potential replay attack.")
            return

        self.replay_counter = r
        self.state = PTKState.PTK_NEGOTIATING

        self.install_ptk_and_gtk(self.tptk, gtk)

    def reset_handshake(self):
        """
        Resets the handshake state to PTK_INIT, discarding any partial keys.

        This method clears out nonces and keys (PTK and GTK) and resets the replay counter,
        allowing a new handshake to begin.
        """
        self.state = PTKState.PTK_INIT
        self.anonce = None
        self.snonce = None
        self.ptk = None
        self.gtk = None
        self.replay_counter = 0


if __name__ == "__main__":
    # Example usage of the Client.
    # A PMK, client MAC, and AP MAC are provided to create a Client instance.
    pmk_example = b"ExamplePMK"
    mac_example = "A2:4B:C9:8D:7F:12"
    access_point_mac_example = "3E:91:FA:65:BC:08"
    client = Client(pmk_example, mac_example, access_point_mac_example)

    # Simulate receiving Message 1 from the access point.
    client.handle_message_1({"ANonce": b"example", "r": 1})

    # Simulate receiving Message 3 from the access point.
    client.handle_message_3({"gtk": b"ExampleGTK", "r": 2})

    # Proof-of-concept for encryption:
    # Encrypts a message and demonstrates basic operations (not a real KRACK demonstration).
    m1 = np.frombuffer(b"holaaaa", dtype=np.uint8)
    enc1 = np.frombuffer(client.send_message(b"holaaaa"), dtype=np.uint8)
    k = np.bitwise_xor(m1, enc1)

    # Re-install keys (if necessary) and encrypt another message.
    client.install_ptk_and_gtk(client.tptk, client.gtk)
    enc2 = np.frombuffer(client.send_message(b"secreto"), dtype=np.uint8)
    print(np.bitwise_xor(k, enc2).tobytes())
