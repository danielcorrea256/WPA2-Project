"""
entity.py

This module defines the Entity class, which provides methods for cryptographic
operations used in WPA2-like key management systems. The Entity class includes
methods for generating nonces using a pseudorandom function (PRF) that combines
randomness, the entity's MAC address, and the current NTP time; calculating the
Pairwise Transient Key (PTK) based on nonces and MAC addresses; installing the
PTK and Group Temporal Key (GTK); and encrypting messages using AES in CTR mode.

Dependencies:
    - pycryptodome: For AES encryption and counter utilities.
    - secrets, time: Standard Python modules.
    - pseudorandom: Custom module providing a PRF implementation.
"""


from Crypto.Cipher import AES
from Crypto.Util import Counter
import secrets
import time
import pseudorandom


class Entity:
    """
    Represents an entity in a WPA2-like key management system, capable of
    generating nonces, calculating cryptographic keys, and encrypting messages.

    Attributes:
        pmk (bytes): Pairwise Master Key used as the base for key derivation.
        mac (str): MAC address of the entity.
        anonce (bytes or None): AP-provided nonce (ANonce), initially None.
        snonce (bytes or None): Supplicant-generated nonce (SNonce), initially None.
        tptk (bytes or None): Temporary Pairwise Transient Key, initially None.
        ptk (bytes or None): Final Pairwise Transient Key, initially None.
        kck (bytes or None): Key Confirmation Key, not used in this context.
        gtk (bytes or None): Group Temporal Key, initially None.
        tk (bytes or None): Temporal Key for unicast encryption, initially None.
        replay_counter (int): Counter for replay protection, initially 0.
        counter_encryption (Counter or None): AES-CTR counter object for encryption.
        cipher (AES or None): AES cipher object configured for CTR mode.
    """


    def __init__(self, pmk, mac):
        """
        Initializes a new Entity with the provided Pairwise Master Key (PMK) and MAC address.

        Args:
            pmk (bytes): The Pairwise Master Key.
            mac (str): The MAC address of the entity.
        """
        self.pmk = pmk
        self.mac = mac
        
        self.anonce = None
        self.snonce = None
        self.tptk = None
        self.ptk = None
        self.kck = None
        self.gtk = None
        self.tk = None
        self.replay_counter = 0
        self.counter_encryption = None
        self.cipher = None


    def generate_nonce(self) -> bytes:
        """
        Generates a pseudorandom nonce (SNonce) using a combination of randomness,
        the entity's MAC address, and the current NTP time.

        The method performs the following steps:
          1. Generates 256 bits of randomness.
          2. Obtains the current Unix time and converts it to NTP time.
          3. Uses a pseudorandom function (PRF) to combine the random bits, the MAC address,
             and the NTP time bytes into a 256-bit nonce.

        Returns:
            bytes: A 256-bit pseudorandom nonce (SNonce).
        """
        key_int = secrets.randbits(256)
        key_bytes = key_int.to_bytes(256 // 8)

        # Get current Unix time (seconds since 1970-01-01)
        unix_time = time.time()

        # Convert to NTP time (offset from 1900-01-01)
        ntp_time = int(unix_time) + 2208988800
        bytes_ntp = (ntp_time.bit_length() + 7) // 8
        ntp_time_bytes = int.to_bytes(ntp_time, bytes_ntp)
        return pseudorandom.prf(key_bytes, b"Init Counter", self.mac + ntp_time_bytes, 256)
    

    def calc_ptk(self, spa: bytes, aa: bytes, snonce: bytes, anonce: bytes) -> bytes:
        """
        Calculates the Pairwise Transient Key (PTK) for CCMP based on the provided parameters.

        The PTK is derived from:
          - The Pairwise Master Key (PMK)
          - The nonces: ANonce (from the AP) and SNonce (generated by the entity)
          - The MAC addresses: SPA (client) and AA (access point)

        The derivation process involves:
          1. Converting the MAC addresses and nonces to integer values.
          2. Concatenating the minimum and maximum of each pair to ensure consistency.
          3. Using the pseudorandom function (PRF) with the PMK, a label, and the concatenated data.

        Args:
            spa (bytes): The client's MAC address in byte format.
            aa (bytes): The access point's MAC address in byte format.
            snonce (bytes): The SNonce generated by the client.
            anonce (bytes): The ANonce received from the access point.

        Returns:
            bytes: A 384-bit output of the PRF representing the PTK.
        """
        x = b"".join(map(lambda x: int.to_bytes(x, (x.bit_length() + 7) // 8), [
            min(int.from_bytes(aa), int.from_bytes(spa)),
            max(int.from_bytes(aa), int.from_bytes(spa)),
            min(int.from_bytes(anonce), int.from_bytes(snonce)),
            max(int.from_bytes(anonce), int.from_bytes(snonce))
        ]))

        return pseudorandom.prf(self.pmk, b"Pairwise Key Expasion", x, 384)
    

    def install_ptk_and_gtk(self, ptk: bytes, gtk: bytes):
        """
        Installs the final Pairwise Transient Key (PTK) and Group Temporal Key (GTK)
        into the entity's security context.

        This method performs the following:
          1. Stores the full PTK and GTK.
          2. Extracts the Temporal Key (TK) portion from the PTK for unicast encryption.
             (Assumes the TK is 128 bits, starting after the first 256 bits of PTK.)
          3. Initializes an AES cipher in CTR mode using the extracted TK and a counter.

        Args:
            ptk (bytes): The full 384-bit PTK derived from `calc_ptk()`.
            gtk (bytes): The Group Temporal Key from Message 3.
        """
        self.ptk = ptk
        self.gtk = gtk

        # Extract the TK portion from PTK (assuming 128 bits for CCMP)
        start_byte = 256 // 8
        end_byte = (256 + 128) // 8
        self.tk = ptk[start_byte:end_byte]

        # Prepare an AES-CTR cipher with the TK
        self.counter_encryption = Counter.new(
            128,             # 128 bits for the full counter block
            initial_value=1  # Start counting at 1
        )
        self.cipher = AES.new(self.tk, AES.MODE_CTR, counter=self.counter_encryption)
    

    def send_message(self, message: bytes) -> bytes:
        """
        Encrypts a plaintext message using AES-CTR mode with the installed Temporal Key (TK).

        This method uses the AES cipher (initialized in `install_ptk_and_gtk`) to encrypt the
        provided message. If the cipher is not yet initialized, a ValueError is raised.

        Args:
            message (bytes): The plaintext message to be encrypted.

        Returns:
            bytes: The ciphertext resulting from AES-CTR encryption.

        Raises:
            ValueError: If the cipher has not been initialized (i.e., PTK has not been installed).
        """
        if not self.cipher:
            raise ValueError("Cipher not initialized. Install PTK first.")
        ciphertext = self.cipher.encrypt(message)
        return ciphertext
