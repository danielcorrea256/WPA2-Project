"""
client.py

Implements a simplified WPA2 client (supplicant) key management state machine
using a 4-Way Handshake-like process. Demonstrates how the client might handle
Message 1 and Message 3, generate the PTK, and install both PTK and GTK.

Example Usage:
    1. Create a Client instance with a PMK, client MAC, and AP MAC.
    2. Receive Message 1 to transition to PTK_START.
    3. Receive Message 3 to install keys and finalize the handshake.
    4. Use the installed TK to encrypt traffic in AES-CTR mode.
"""

from enum import Enum, auto
from pseudorandom import prf
from Crypto.Cipher import AES
from Crypto.Util import Counter
import numpy as np
import secrets
import time

class PTKState(Enum):
    """Enumeration of the PTK state machine states."""
    PTK_INIT = auto()
    PTK_START = auto()
    PTK_NEGOTIATING = auto()
    PTK_DONE = auto()


class Client:
    """A simplified client (supplicant) state machine for WPA2 4-Way Handshake key management.

    This class models the states and transitions of a client during a WPA2
    4-Way Handshake, including how it handles Message 1 and 3, computes the
    PTK, and installs the final keys. It also provides an example of sending
    encrypted messages via AES-CTR using the derived Temporal Key (TK).

    Attributes:
        state (PTKState): Current state in the PTK handshake flow.
        pmk (bytes): The Pairwise Master Key (PMK), derived from a PSK or 802.1X/EAP.
        mac (str): The MAC address of this client (supplicant).
        anonce (bytes): ANonce received from the AP in Message 1.
        snonce (bytes): SNonce generated by this client in PTK_START state.
        tptk (bytes): "Temporary" PTK computed before final installation.
        ptk (bytes): The final installed Pairwise Transient Key.
        kck (bytes): The Key Confirmation Key (not fully utilized here).
        gtk (bytes): The Group Temporal Key from Message 3.
        tk (bytes): The Temporal Key (subset of PTK) used to encrypt unicast data.
        access_point_mac (str): MAC address of the access point (authenticator).
        replay_counter (int): Tracks replay counter values for handshake messages.
        counter_encryption (Counter): AES-CTR counter object for data encryption.
        cipher (AES): AES cipher object for encrypting traffic in CTR mode.
    """

    def __init__(self, pmk: bytes, mac: str, access_point_mac: str):
        """Initializes the client state machine with a PMK, client MAC, and AP MAC.

        Args:
            pmk (bytes): The Pairwise Master Key.
            mac (str): MAC address of this client.
            access_point_mac (str): MAC address of the access point.
        """
        self.state = PTKState.PTK_INIT
        self.pmk = pmk
        self.mac = mac

        self.anonce = None
        self.snonce = None
        self.tptk = None
        self.ptk = None
        self.kck = None
        self.gtk = None
        self.tk = None
        self.access_point_mac = access_point_mac
        self.replay_counter = 0
        self.counter_encryption = None
        self.cipher = None


    def handle_message_1(self, message1: dict):
        """Handles receipt of Message 1 of the 4-Way Handshake.

        Transitions from PTK_INIT or PTK_START to PTK_START, storing
        the ANonce and replay counter, then generating SNonce and a
        temporary PTK (tPTK).

        Args:
            message1 (dict): Dictionary representing Message 1, with keys:
                - "ANonce" (bytes): The ANonce from the AP.
                - "r" (int): The replay counter from the AP.
        """
        if self.state not in [PTKState.PTK_INIT, PTKState.PTK_START]:
            return

        self.anonce = message1["ANonce"]
        self.replay_counter = message1["r"]

        self.state = PTKState.PTK_START
        self.snonce = self.generate_snonce()
        self.tptk = self.calc_ptk()


    def send_message_2(self) -> dict:
        """Constructs and returns Message 2 of the 4-Way Handshake.

        Returns:
            dict: A dictionary representing Message 2, containing:
                - "r" (int): Current replay counter.
                - "SNonce" (bytes): The client's SNonce.
        """
        message2 = {
            "r": self.replay_counter,
            "SNonce": self.snonce
        }
        return message2


    def send_message_4(self) -> dict:
        """Constructs and returns Message 4 of the 4-Way Handshake.

        Returns:
            dict: A dictionary representing Message 4, containing:
                - "r" (int): Current replay counter.
        """
        message4 = {
            "r": self.replay_counter
        }
        return message4


    def handle_message_3(self, message3: dict):
        """Handles receipt of Message 3 of the 4-Way Handshake.

        Transitions to PTK_NEGOTIATING if valid, installs PTK/GTK, and
        finalizes the handshake.

        Args:
            message3 (dict): Dictionary representing Message 3, with keys:
                - "gtk" (bytes): The Group Temporal Key from the AP.
                - "r" (int): The replay counter from the AP.
        """
        if self.state not in [PTKState.PTK_START, PTKState.PTK_NEGOTIATING]:
            return

        gtk = message3["gtk"]
        r = message3["r"]

        # Replay counter check
        if r <= self.replay_counter:
            print("Error: Replay counter did not increase. Potential replay attack.")
            return

        self.replay_counter = r
        self.state = PTKState.PTK_NEGOTIATING

        self.install_ptk_and_gtk(self.tptk, gtk)


    def reset_handshake(self):
        """Resets the handshake to PTK_INIT, discarding partial keys."""
        self.state = PTKState.PTK_INIT
        self.anonce = None
        self.snonce = None
        self.ptk = None
        self.gtk = None
        self.replay_counter = 0


    def send_message(self, message: bytes) -> bytes:
        """Encrypts and returns a message using the installed cipher (AES-CTR).

        Args:
            message (bytes): The plaintext message to be encrypted.

        Returns:
            bytes: The ciphertext resulting from AES-CTR encryption.
        """
        if not self.cipher:
            raise ValueError("Cipher not initialized. Install PTK first.")
        ciphertext = self.cipher.encrypt(message)
        return ciphertext


    # ----------------------------------------------------------------------
    # Placeholder / Helper Methods
    # ----------------------------------------------------------------------

    def generate_snonce(self) -> bytes:
        """Generates the SNonce (client's nonce) using random bits and NTP time.

        This uses a pseudorandom function (PRF) to combine:
        - 256 bits of randomness
        - The client's MAC address
        - Current NTP time

        Returns:
            bytes: A 256-bit pseudorandom SNonce.
        """
        key_int = secrets.randbits(256)
        key_bytes = key_int.to_bytes(256 // 8)

        # Get current Unix time (seconds since 1970-01-01)
        unix_time = time.time()

        # Convert to NTP time (add offset for 1900 epoch)
        ntp_time = int(unix_time) + 2208988800

        return prf(key_bytes, "Init Counter", self.mac + str(ntp_time), 256)


    def calc_ptk(self) -> bytes:
        """Calculates the Pairwise Transient Key (PTK) for CCMP.

        The PTK is derived from:
          - PMK
          - ANonce, SNonce
          - MAC addresses of the AP (AA) and client (SPA)

        Returns:
            bytes: A 384-bit output of the PRF, representing the PTK.
        """
        spa = self.mac
        aa = self.access_point_mac

        anonce_val = int.from_bytes(self.anonce)
        snonce_val = int.from_bytes(self.snonce)

        x = (
            min(aa, spa)
            + max(aa, spa)
            + str(min(anonce_val, snonce_val))
            + str(max(anonce_val, snonce_val))
        )

        return prf(self.pmk, "Pairwise Key Expasion", x, 384)


    def install_ptk_and_gtk(self, ptk: bytes, gtk: bytes):
        """Installs the final PTK and GTK into the system's security context.

        Derives the temporal key (TK) for unicast encryption, then
        initializes AES-CTR with that TK.

        Args:
            ptk (bytes): The full 384-bit PTK derived from calc_ptk().
            gtk (bytes): The Group Temporal Key from Message 3.
        """
        self.ptk = ptk
        self.gtk = gtk

        # Extract the TK portion from PTK (assuming 128 bits for CCMP)
        start_byte = 256 // 8
        end_byte = (256 + 128) // 8
        self.tk = ptk[start_byte:end_byte]

        # Prepare an AES-CTR cipher with the TK
        self.counter_encryption = Counter.new(
            128,             # 128 bits for the full counter block
            initial_value=1  # Start counting at 1
        )
        self.cipher = AES.new(self.tk, AES.MODE_CTR, counter=self.counter_encryption)


if __name__ == "__main__":
    # Example usage of the Client
    pmk_example = b"ExamplePMK"
    mac_example = "A2:4B:C9:8D:7F:12"
    access_point_mac_example = "3E:91:FA:65:BC:08"
    client = Client(pmk_example, mac_example, access_point_mac_example)

    # Simulate receiving Message 1
    client.handle_message_1({"ANonce": b"example", "r": 1})

    # Simulate receiving Message 3
    client.handle_message_3({"gtk": b"ExampleGTK", "r": 2})
    client.send_message_4()

    # Proof-of-concept for encryption (not a real KRACK demonstration)
    m1 = np.frombuffer(b"holaaaa", dtype=np.uint8)
    enc1 = np.frombuffer(client.send_message(b"holaaaa"), dtype=np.uint8)
    k = np.bitwise_xor(m1, enc1)

    client.install_ptk_and_gtk(client.tptk, client.gtk)
    enc2 = np.frombuffer(client.send_message(b"secreto"), dtype=np.uint8)
    print(np.bitwise_xor(k, enc2).tobytes())
